https://stackoverflow.com/questions/53163998/could-not-open-port-error-immediately-after-plugging-in-arduino-on-arch-linux
pkill -STOP ModemManager
pkill -CONT ModemManager


ISL9204 - зарядка уккумулятора --ok
SWD --ok
LCD --ok

display 320x240 ILI9341
https://ru.aliexpress.com/item/4000001584187.html - дешевый и с резистивным дисплеем HT024SQV003NH
Можно протестировать на нем toush display. Да, основной недостаток - плохое светопроопускание.

https://ru.aliexpress.com/item/33004513214.html - как в старинные времена покупал дисплейчики


LTC1550LCMS8-2 - -2 вольта стабилизированных --ok
TPS60241DGKR - +5V стабилизированных VSSOP DGK 8 --ok
FSA3357L8X - 3:1 switch
AD8221 (AD8421 имеет такойже pinout)
AD9833

Забыли AD8221 заказать
Заодно закажем ОУ чтобы по одной штуке были
AD8031ARTZ - использовать как мощный ОУ перед ADC и на выходе DDS.

Про усиление на каскадах.
	По хорошему должно быть не более 200 мв сигнала.
	Мы будем использовать весь диапазон, поэтому.
	K = 3.3 V / 0.2 V = 16.5

	Пускай в предусилителе ОУ будет KU=3
	Тогда в инструментальном нужен KU = 5
	Нкжен резистор на 12 KOm


Ищем мелкие энкодеры (желательно на край корпуса)
	EVQWKA001 неплохой и с документацией
	https://ru.aliexpress.com/item/33049515970.html
	https://ru.mouser.com/datasheet/2/315/panasonic_atc0000ce27-1196962.pdf

	EVQWKL001 - похожий, но головка побольше
	https://ru.aliexpress.com/item/33051910087.html

	https://ru.aliexpress.com/item/32813163679.html - SIQ-02FVS3 тоже вполне разумный вариант

------------------------------------
STM32H7 ADC пины
PC0 ADC123_INP10
PC2_C ADC3_INN1, ADC3_INP0
PC3_C ADC3_INP1

PA0 ADC1_INP16
PA1 ADC1_INN16, ADC1_INP17
PA2 ADC12_INP14
PA3 ADC12_INP15
PA4 ADC12_INP18, DAC1_OUT1
PA5 ADC12_INN18, ADC12_INP19, DAC1_OUT2
PA6 ADC12_INP3
PA7 ADC12_INN3, ADC12_INP7
PC4 ADC12_INP4
PC5 ADC12_INN4, ADC12_INP8
PB0 ADC12_INN5, ADC12_INP9
PB1 ADC12_INP5

Ищем пары 
ADC3 имеет пару комплементарных быстрых каналов, 
ADC12 только позитивные быстрые каналы имеет
PC2_C ADC3_INN1, PC3_C ADC3_INP1 -- fast channel pair

PA0 ADC1_INP16, PA1 ADC1_INN16
PA4 ADC12_INP18, PA5 ADC12_INN18
PA6 ADC12_INP3 (f),  PA7 ADC12_INN3
PC4 ADC12_INP4 (f), PC5 ADC12_INN4
PB0 ADC12_INN5, PB1 ADC12_INP5 (f)

8.5 циклов, чтобы 16 бит обработать
1.5, 2.5, 8.5 циклов сэмплинг
Расчитаем для 24 МГц скорость сэмплирования

1.5 + 8.5 -> 2.4 MHz 
2.5 + 8.5 -> 2.1818 MHz 
8.5 + 8.5 -> 1.4117 MHz 


Прикупить низкошумящих конвертеров на +5V
Сделать спектроанализатор до 100 КГц звукового сигнала.

LTC1550LCMS8-2 - -2 вольта стабилизированных (1.3$ 20 ma) +
TPS60241 - +5V стабилизированных (0.8$ 25 ma) +

MCP73831 - заказать, так как почти закончились
XC6802A42XMR  - похож на MCP73831 но дешевле
bq25100B - идеальный charder для 50 ma-h LiIon еще и в забавном BGA-6 корпусе, правда без индикации конца заряда.
BQ25101Y - имеет таки выход на индикацию +

ISL9204 - хороший вариант с низким током разряда батареи, с индикацией и ценой 0.3$ +
	https://batteryuniversity.com/learn/article/charging_lithium_ion_batteries - end-of-charging надо задавать 20-30% от тока константной зарядки

FSA3357L8X - 3:1 switch - имеет низкую емкость и сопротивление. Можно 100 Ом, 1 КОм, 10 КОм вполне успешно переключать +

SPH0641LU4H-1 - MEMS микрофон, можно будет слушать ультразвук (PDM interface, так что сразу цифровой сигнал на выходе, хоть и однобитный) точности на высоких частотах от него не добиться.
SPU1410LR5H-QB - MEMS микрофон с аналоговым выходом, можно много выжать из него (нет в utsource)

Подумать какой бы разем итспользовать

Будем использовать AD9833 в качестве качественного DAC/DDS
Пускай процессор и DDS работают от одного генератора, чтобы частота не плавала сильно.
Резисторы будем использовать 100, 1k, 10k. 100k вариант пожалуй слишком экстремален, да и switch на 3 положения имеет меньшую емкость.
	100 om +
	1 k +
	5.1 k +
	10 k +

Разъем пусть будет GX16 5 PIN (или 4?)
	Купить еще щупы кельвина.

Нужен экранированный кабель с 2-мя жилами внутри.
Кнопки 
	- быстрый выбор настроек кабеля.
	- быстрый выбор частоты

По хорошему неплохо бы напряжение подавать на конденсаторы, чтобы измерять при разном напряжении.
Для того, чтобы тестировать конденсаторы большой емкости нужна совсем другая система.
	- нужно иметь возможность подавать напряжение на конденсатор.
	- желательно вход сделать высоковольтным (до 20-ти вольт)
	- резистора видимо достаточно 100 Ом непереключаемого
	- частоты должны быть 10 Гц -- 1 КГц



Чтобы меньше шумело питание - нужно делать буферы для ОУ как в статье https://radiokot.ru/artfiles/6503/


Как вариант полностью отказаться от кнопок, и перейти на touch display

----------------------------------------------------------------------------------------------------------------


GCC_PATH = ${ARM_NONE_EABI}

python ~/radio/stm32/tools/stm32_flash_0.py /home/balmer/radio/stm32/tmp/TestH743_USB_1/build/TestH743_USB.bin

- попробовать сделать Speed Test на STM32H7

void speedLoop()
{
    for(int i=0; i<ARRAY_SIZE; i++)
    {
        float f = array_a[i]*array_b[i]+array_c[i];
        if(f>10.0f || f<-10.0f)
            f *= 0.2f;

        array_c[i] = f;
    }
}

	time taken 0.063690 seconds на  Intel Core 7 mobile (10000 loop count)
	10.220 seconds на STM32H7 (96 MHz) данные и так лежали в DTCM RAM (т.е. в самой быстрой)
	4.971 seconds на STM32H7 (480 MHz)


void speedLoop()
{
    for(int i=0; i<ARRAY_SIZE; i++)
    {
        float f = array_a[i]*array_b[i]+array_c[i];
        array_c[i] = f;
    }
}

	time taken 0.032620 seconds на  Intel Core 7 mobile (10000 loop count)

	ICache disable
	5.553  seconds на STM32H7 (96 MHz)
	2.903 seconds на STM32H7 (480 MHz)

	ICache enable
	4.269 seconds на STM32H7 (96 MHz)
	0.853 seconds на STM32H7 (480 MHz)
	1.068 seconds на STM32H7 (384 MHz)

	1.025 seconds на STM32H750 (400 MHz)



RV210316637CN


>>> 480e6/10000/4096
11.71875
>>> 488e6/10000/4096*3.
35.7421875
>>> 480e6/10000/4096*3.
35.15625
>>> 1.8e9/10000/4096*0.03
1.318359375
>>> 96e6/10000/4096*5.55
13.0078125




- @$(CC) $(OBJS) $(USER_OBJS) $(LDFLAGS) -o "$(TARGET)_$(MAKECMDGOALS).elf" - правильный порядок требуется, чтобы не было _init неорпределённого и других системных библиотек


- данные принимаются в функции CDC_Receive_FS --ok

- STM32H7 (384 MHz) 148 мА с включенным USB
	Если мы нацеливаемся на 200 мА потребление, то нужна батарея минимум 600 мА-ч

	PWR_REGULATOR_VOLTAGE_SCALE0 - 1.21 V
	PWR_REGULATOR_VOLTAGE_SCALE1 - 1.213 V
	PWR_REGULATOR_VOLTAGE_SCALE2 - 1.129 V
	PWR_REGULATOR_VOLTAGE_SCALE3 - 1.063 V


	Да, вполне выгодно питать ядпро STM32H7 от отдельного Step Down на 1.2V


TPS62207 - 1.2V StepDown 1 MHz 30 Ma 0.3$
TPS62205 - 2.5V
TPS62203 - 3.3V

10 uH
TDK SPM6530T-100M-HZ  - хороший, но большой, точно выдержит 1 МГц и несколько ампер

LVF808040-100M-NGR(10pcs) - слабенький, с трудом держит ток 0.5A, но дешевый и расчитан на 1 МГц



- частота --ok
	
	С кварцем 25 МГц нам надо обеспечить 48 МГц на USB
	STM32F7 работает на частоте 400 МГц

- энкодер --ok

- LCD ILI9341 --ok

- AD9833 --ok


/home/balmer/opt/gcc-arm-none-eabi-8-2019-q3-update/bin/arm-none-eabi-gdb --symbols=output/program_release.elf

- ADC Dual mode 
	- init --ok
	- check data --ok

	отклонение без подключенния ко входу 8-10
	отклонение от среднего в среднем 2200 при подключении DAC на вход ADC

	- получить данные и нарисовать график.

- 
	22453 ms занимало вычисление sinf + cosf вместе со сложением, умножением и выборкой/записью в массивы

	10000*4096 / 22.453 sec = 1 824 255 op/sec

	Т.е в realtime мы не успеваем эти сэмплы обрабатывать с sinf/cosf хардварным

	Надо будет sin/cos в виде таблицы замутить.


Первый вариант
	Есть тригонометрические тождества.
	sin(A+B)=sinA*cosB + cosA*sinB
	sin(A-B)=sinA*cosB - cosA*sinB
	cos(A+B)=cosA*cosB - sinA*sinB
	cos(A-B)=cosA*cosB + sinA*sinB

	Можно например угол A сделать большим (например по градусу изменять)
	Тогда угол B будет в пределах от 0 до 1 градуса. Можно сделать либо таблицу, либо ряд Тейлора.
	Лучше сразу вычислять синус и косинус.
	Для значений до градуса достаточно двух элементов ряда Тейлора чтобы получить 1e-12 точность.
	sin(x) = x - x*x*x/6
	Для максимальной ошибки 3e-7 и таблицы в 512 символов на 2*PI достаточно sin(x) = x для малого угла.
	Если придумать как быстро выбрать квадрант и знак, то можно улолжиться в 512/4 = 128 отсчетов.
	Пускай x = 0..511 это в пределах x=0 - 0 градусов. x=512  - 360 градусов.
	Старший бит - знак.
	Бит перед старшим - знак инверсии отсчетов в массиве.
	array_index = x&127
	if(x&128)
		array_index = 128-array_index (или всетаки 127-array_index)? 
	sin_x = sin_table[array_index]
	if(x&256)
		sin_x = -sin_x

	понятно, что делать это надо все в fixed point
	Можно воспользоваться arm_sin_cos_q31 и остальной математикой

	speedLoopSinCosq31 - 8399 ms
	Получается 4.8e6 циклов в секунду. А нам надо 2 мегациклаm в секунду, т.е. вполне есть шансы уложиться.

	82 такта на цикл. 



Развязали по простоянному току AD8221 и AD8031 стоящий после.

Возбуждается I-V converter из-за цепочки R22 C26, получается сигнал амплитудой почти 4 вольта почти 4 MHz
R22 заменим на 1 Ом
С26 выпаяем
Между ножками 4 и 1 усилителя U11 впаяем конденсатор емкостью 33 pF (это приблизительно 10 КОм на чатоте 500 КГц).


Частота не та сэмплирования.
2.5 цикла ожидания - 68681 Гц вместо 50000 Гц
8.5 цикла ожидания - 106203 Гц

8.5-2.5 = 6 

(6+x)/106203 = x/68681
6/106203 = x/68681-x/106203

x = 6/106203/(1/68681-1/106203)

Получается 11 тактов

Но частота не та, прикинем на какой частоте у нас работает ADC
Получается 16 МГц? Не успеваем чтоли обработать?

При ADC_CLOCK_ASYNC_DIV8 (вместо ADC_CLOCK_ASYNC_DIV8) получается 137400

1455400 SPS намеряли

Умножаем на 11 тактов, получается опять 16 МГц, а должно быть 22 МГц!!!!

Неверное clock source выбирали.
__HAL_RCC_ADC_CONFIG(RCC_ADCCLKSOURCE_CLKP); -> __HAL_RCC_ADC_CONFIG(RCC_ADCCLKSOURCE_PLL2);


freq = 400
AD9833_MASTER_CLOCK = 25e6
w = int((freq*(1<<28)+AD9833_MASTER_CLOCK/2)/AD9833_MASTER_CLOCK)
f1 = w*AD9833_MASTER_CLOCK/(1<<28)

- написать еще раз sin_cos_q31 функцию
	- проверить корректность работы
	- замерять производительность на устройстве

8813 ms наш вариант с вычисленными налету sin/cos без инвалидации кеша
9006 ms с инвалидацией кеша
Т.е. это будет занимать 44% времени работы процессора. Как-бы очень-очень впритык, но успеваем.
Ничего кроме вычислений в это время не получится делать явно.

Избавились от int64 практически не потеряв в точности.
8839 ms с инвалидацией кеша

- посмотреть на HAL_ADC_ERROR_OVR флаг, часто ли он просиходит --ok
 не происходит никогда, но скорость выполнения остального кода действительно примерно в 2 раза падает

- припаять входные щупы, посмотреть на фазу и амплитуду данных --ok

- разобраться, почему так сильно прыгают данные от измерения к измерению

https://fb2-epub.ru/load/1001/ostrov_sokrovishh/665-1-0-1237

- используя HT7333 успешно запустили USB (раньше не запускался почемуто) --ok

- проверить осциллографом шумы по питанию --ok
	если шумит процессор, то добавить еще одну HT7333 для 3.3VA
	добавили, стало вразы лучше, на финальную схему достаточно MCP1700 для аналогового питания.

- сделать FFT на python для нашего сигнала --ok

- добавить режим, где устанавливается список частот из питона, обратно приходит список результатов
	список требуемых режимов
	- измерение Z и вывод результатов на экран (основной режим)
	- сэмплирование буфера и передача результатов по USB --ok
	- установка частоты, ожидание результата Zx, пакетное --ok

- чтение/запись во Flash --ok
	- m25p16_read_ram_id_and_check  --ok
	- добавить read/write сектора не по байтам, а сразу массива --ok

- ток утечки аккумулятора менее 0.25 uA --ok

- простенькая плата для запайки туда SMD компонентов --ok

- немножко интерфейса и нажатия на кнопки
	- вращение энкодера изменяет текущую частоту --ok
	- нажатие на кнопку вызывает меню
		в нем пока будет пункты
		change view mode
		select calibration
			no calibration
			calibration 1
		make calibration
			пока у нас одна калибровка, суффиксов не будем добавлять

	- так как места много, то выводить внизу текущий резистор выбранный --ok


- OSL калибровка
	Калибровка естественно происходит при куче разных частот.
	Потом будем интерполировать между этими частотами возможно.

	Для short мы измеряем Zsm короткозамкнутые щупы. Это надо проделать для резистора 100 Ом.
	В будущем будет 2 Zsm для разных коэффициентов усиления по напряжению.

	Для open мы измеряем открытые щупы. Это надо проделать для всех резисторов.
	Когда появится усиление по току, для резисора 10 КОм надо будет измерить с усилением по току.

	Для load измеряем так. 100 Ом для резистора 100 Ом. 1 КОм для резистора 1 КОм. 10 КОм для резистора 10 КОм.
	Когда появится усиление по току, для резисора 10 КОм надо будет измерить с усилением по току резистор 100 КОм.

	Диалог калибровки пускай представляется в виде меню.
		Суффикс - ok появляется после успешного прохождения калибровки.
		Short calibration (- ok)
		100 Om calibration (- ok)
		1 KOm calibration (- ok)
		10 KOm calibration (- ok)
		Save & Exit
		Discard & Exit

	- добавить в Task возможность принудительно выбирать резистор для калибровки --ok
		в будущем еще и коэффициент усиления добавим

	- записать/прочитать калибровку в flash --ok
	- применить калибровку к данным --ok

- при 10 КОм, измерении малого резистора и высокой частоте наблюдаются проблемы с амплитудой сигнала --ok
	вместо очень большой она становится маленькой
	попробуем сыграть на факте, что abs(a) и abs(b) не могут быть одновременно маленькими
